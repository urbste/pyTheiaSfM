"""Type stubs for the pytheia.matching module."""
from typing import Dict, List, Optional, Set, Tuple, Union, Any
import numpy as np
from numpy.typing import NDArray
from enum import Enum

class FeaturesAndMatchesDatabase:
    """Base class for features and matches database."""
    pass

class InMemoryFeaturesAndMatchesDatabase(FeaturesAndMatchesDatabase):
    def __init__(self) -> None: ...
    def ContainsFeatures(self, image_name: str) -> bool: ...
    def GetFeatures(self, image_name: str) -> Any: ...  # Return type should be KeypointsAndDescriptors
    def PutFeatures(self, features: Any) -> None: ...  # Parameter type should be KeypointsAndDescriptors
    def ImageNamesOfFeatures(self) -> List[str]: ...
    def NumImages(self) -> int: ...
    def GetImagePairMatch(self, image1: str, image2: str) -> Any: ...  # Return type should be ImagePairMatch
    def PutImagePairMatch(self, match: Any) -> None: ...  # Parameter type should be ImagePairMatch
    def NumMatches(self) -> int: ...
    def PutCameraIntrinsicsPrior(self, image_name: str, camera_intrinsics_prior: Any) -> None: ...
    def GetCameraIntrinsicsPrior(self, image_name: str) -> Any: ...
    def NumCameraIntrinsicsPrior(self) -> int: ...
    def ImageNamesOfCameraIntrinsicsPriors(self) -> List[str]: ...
    def ImageNamesOfMatches(self) -> List[str]: ...
    def ContainsCameraIntrinsicsPrior(self, image_name: str) -> bool: ...

class ImagePairMatch:
    def __init__(self) -> None: ...
    image1: str
    image2: str
    twoview_info: Any  # Actual type should be TwoViewInfo
    correspondences: List[Any]  # List[FeatureCorrespondence]

class FeatureCorrespondence:
    def __init__(self) -> None: ...
    def __init__(self, feature1: Any, feature2: Any) -> None: ...  # Feature types
    feature1: Any  # Feature type
    feature2: Any  # Feature type

class FeatureMatcherOptions:
    def __init__(self) -> None: ...
    num_threads: int
    keep_only_symmetric_matches: bool
    use_lowes_ratio: bool
    lowes_ratio: float
    perform_geometric_verification: bool
    min_num_feature_matches: int
    geometric_verification_options: Any  # TwoViewMatchGeometricVerificationOptions

class KeypointsAndDescriptors:
    def __init__(self) -> None: ...
    image_name: str
    keypoints: List[Any]  # List of keypoints
    descriptors: NDArray  # Descriptor matrix

class IndexedFeatureMatch:
    def __init__(self) -> None: ...
    def __init__(self, feature1_ind: int, feature2_ind: int, distance: float) -> None: ...
    feature1_ind: int
    feature2_ind: int
    distance: float

class GlobalDescriptorExtractor:
    """Base class for global descriptor extraction."""
    pass

class FisherVectorExtractorOptions:
    def __init__(self) -> None: ...
    num_gmm_clusters: int
    max_num_features_for_training: int

class FisherVectorExtractor(GlobalDescriptorExtractor):
    def __init__(self, options: FisherVectorExtractorOptions) -> None: ...
    def AddFeaturesForTraining(self, descriptor: NDArray) -> None: ...
    def Train(self) -> bool: ...
    def ExtractGlobalDescriptor(self, descriptors: NDArray) -> NDArray: ...

class FeatureMatcher:
    """Base class for feature matchers."""
    def AddImages(self, image_names: List[str]) -> None: ...
    def AddImage(self, image_name: str) -> None: ...
    def MatchImages(self) -> int: ...
    def SetImagePairsToMatch(self, pairs_to_match: List[Tuple[str, str]]) -> None: ...

class BruteForceFeatureMatcher(FeatureMatcher):
    def __init__(self, options: FeatureMatcherOptions, database: FeaturesAndMatchesDatabase) -> None: ...

class CascadeHashingFeatureMatcher(FeatureMatcher):
    def __init__(self, options: FeatureMatcherOptions, database: FeaturesAndMatchesDatabase) -> None: ...
    def AddImages(self, image_names: List[str]) -> None: ...
    def AddImage(self, image_name: str) -> None: ...

class MatchingStrategy(Enum):
    BRUTE_FORCE = ...  # Actual value
    CASCADE_HASHING = ...  # Actual value

def GraphMatch(adjacency_matrix_1: NDArray, adjacency_matrix_2: NDArray) -> Tuple[List[int], float]: ...